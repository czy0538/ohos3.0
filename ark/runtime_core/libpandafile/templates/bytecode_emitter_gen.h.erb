/*
 * Copyright (c) 2021 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

template <Format format, typename It, typename... Types>
static size_t Emit(It out, Types... args) { // NOLINT(readability-function-size)
    size_t insn_len = 0;

% insns_uniq_sort_fmts.each do |i| # Panda::formats.each do |fmt|
%   fmt = i.format
%   ops = i.operands
%   offsets = [0]  # for opcode
%   offsets += ops.map(&:offset).sort
%   offsets += [fmt.size * 8]  # terminating offset, used for calculating last operand encoding width
%
    // Disable check due to clang-tidy bug https://bugs.llvm.org/show_bug.cgi?id=32203
    // NOLINTNEXTLINE(readability-braces-around-statements, bugprone-suspicious-semicolon)
    if constexpr (format == Format::<%= fmt.pretty.upcase %>) {
        constexpr size_t SIZE = <%= fmt.size %>;
        constexpr std::array<uint8_t, <%= offsets.size %>> OFF{<%= offsets.join(', ') %>};
        static_assert(OFF.size() == sizeof...(args) + 1);
        std::array<uint8_t, SIZE> buf{};
        Span<uint8_t> buf_sp(buf);
        Span<const uint8_t> off_sp(OFF);
        EmitImpl(buf_sp, off_sp, args...);
        std::copy(buf.begin(), buf.end(), out);
        insn_len = SIZE;
    }

% end
    return insn_len;
}

% OPCODE_TYPE = 'BytecodeInstruction::Opcode'
% FORMAT_TYPE = 'BytecodeInstruction::Format'
%
% def opcode_full_name(i)
%   OPCODE_TYPE + '::' + i.opcode.upcase
% end
%
% def format_full_name(i)
%   FORMAT_TYPE + '::' + i.format.pretty.upcase
% end
%
% Panda::instructions.group_by(&:mnemonic).each do |mnemonic, group|
%   emitter_name = group.first.emitter_name
%   formats = group.map(&:format)
%
%   if emitter_name == "Jmp"
%       next
%   end
%
%   signature = emitter_signature(group, group.first.jump?)
%   signature_str = signature.map { |o| "#{o.type} #{o.name}" }.join(', ')
%
// NOLINTNEXTLINE(misc-definitions-in-headers)
void BytecodeEmitter::<%= emitter_name %>(<%= signature_str %>) {
%
%   method_args = signature.map(&:name)
%   opcodes = group.map { |i| opcode_full_name(i) }
%
%   i = group[0]
%
%   if i.jcmpz?
    Jcmpz(<%= opcodes[0] %>, <%= method_args.join(', ') %>);
%   elsif i.jcmp?
    Jcmp(<%= opcodes.join(', ') %>, <%= method_args.join(', ') %>);
%   elsif group.length() == 1
%       method_args_str = method_args.join(', ')
%       if method_args_str != ''
%           method_args_str = ', ' + method_args_str
%       end
%       format = format_full_name(i)
%       opcode = opcode_full_name(i)
    pc_ += Emit<<%= format %>>(std::back_inserter(bytecode_), <%= opcode %><%= method_args_str %>);
%   else
%       bitlen_vars = []
%       signature.each do |arg|
%           v = '%s_bitlen' % arg.name
%           bitlen_vars.push(v)
%           if arg.name.start_with?('imm')
    auto <%= v %> = GetBitLengthSigned(<%= arg.name %>);
%           else
    auto <%= v %> = GetBitLengthUnsigned(<%= arg.name %>);
%           end
%       end
%
%       group.each do |i|
%           conditions = []
%           i.operands.each_with_index do |op, index|
%               conditions.push("%s <= BitImmSize::BITSIZE_%d" % [bitlen_vars[index], op.width])
%           end
%           format = format_full_name(i)
%           opcode = opcode_full_name(i)

    if (<%= conditions.join(' && ') %>) {
        pc_ += Emit<<%= format %>>(std::back_inserter(bytecode_), <%= opcode %>, <%= method_args.join(', ') %>);
        return;
    }
%       end
%   end
}

% end

/* static */
// NOLINTNEXTLINE(readability-function-size,misc-definitions-in-headers)
size_t BytecodeEmitter::GetSizeByOpcode(<%= OPCODE_TYPE %> opcode) {
    switch (opcode) {
% Panda::instructions.each do |insn|
    case <%= opcode_full_name(insn) %>:
       return <%= insn.format.size %>;  // NOLINT(readability-magic-numbers)
% end
    default:
        UNREACHABLE();
        return 0;
    }
}

/* static */
// NOLINTNEXTLINE(misc-definitions-in-headers)
BytecodeEmitter::BitImmSize BytecodeEmitter::GetBitImmSizeByOpcode(<%= OPCODE_TYPE %> opcode) {
    switch (opcode) {
% Panda::instructions.each do |insn|
%   if insn.jump?
    case <%= opcode_full_name(insn) %>:
        return BytecodeEmitter::BitImmSize::BITSIZE_<%= insn.operands.select(&:imm?).first.width %>;
%   end
% end
    default:
        UNREACHABLE();
        return BytecodeEmitter::BitImmSize::BITSIZE_32;  // Any return value will do, we are broken here anyway.
    }
}

/* static */
// NOLINTNEXTLINE(misc-definitions-in-headers)
<%= OPCODE_TYPE %> BytecodeEmitter::RevertConditionCode(<%= OPCODE_TYPE %> opcode) {
% CC_INVERTER = {
%       "JEQ" => "JNE",
%       "JNE" => "JEQ",
%       "JLT" => "JGE",
%       "JGE" => "JLT",
%       "JGT" => "JLE",
%       "JLE" => "JGT",
% }
    switch (opcode) {
% Panda::instructions.each do |insn|
%   if insn.conditional?
    case <%= opcode_full_name(insn) %>:
        return <%= OPCODE_TYPE %>::<%= insn.opcode.upcase.sub(/^.../, CC_INVERTER) %>;
%   end
% end
    default:
        UNREACHABLE();
        return <%= OPCODE_TYPE %>::LAST;  // Any return value will do, we are broken here anyway.
    }
}

/* static */
// NOLINTNEXTLINE(misc-definitions-in-headers)
<%= OPCODE_TYPE %> BytecodeEmitter::GetLongestConditionalJump(<%= OPCODE_TYPE %> opcode) {
% JCC_WIDENER = {
%       "_V8_IMM8" => "_V8_IMM16",
%       "_V8_IMM16" => "_V8_IMM16",
%       "_IMM8"     => "_IMM16",
%       "_IMM16"    => "_IMM16",
% }
    switch (opcode) {
% Panda::instructions.each do |insn|
%   if insn.conditional?
    case <%= OPCODE_TYPE %>::<%= insn.opcode.upcase %>:
        return <%= OPCODE_TYPE %>::<%= insn.opcode.upcase.sub(/(_V4_IMM4|_V8_IMM16|_IMM8|_IMM16)$/, JCC_WIDENER) %>;
%   end
% end
    default:
        UNREACHABLE();
        return <%= OPCODE_TYPE %>::LAST;  // Any return value will do, we are broken here anyway.
    }
}
