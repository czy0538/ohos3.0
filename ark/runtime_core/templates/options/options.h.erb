/*
 * Copyright (c) 2021 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

#ifndef PANDA_<%= Common::module.name.upcase %>_OPTIONS_GEN_H_
#define PANDA_<%= Common::module.name.upcase %>_OPTIONS_GEN_H_

#include "utils/pandargs.h"

#include <optional>
#include <string>
#include <unordered_set>
#include <vector>

namespace <%= Common::module.namespace %> {

class Options {
public:
    class Error {
    public:
        explicit Error(std::string msg) : msg_(std::move(msg)) {}

        std::string GetMessage() {
            return msg_;
        }
    private:
        std::string msg_;
    };

    explicit Options(const std::string &exe_path) : exe_dir_(GetExeDir(exe_path)) {}

    void AddOptions(PandArgParser *parser) {
% Common::options.each do |op|
        parser->Add(&<%= op.field_name %>);
% end
    }

% Common::options.each do |op|
    <%= op.type %> <%= op.getter_name %>() const {
        return <%= op.field_name %>.GetValue();
    }

    void <%= op.setter_name %>(<%= op.type %> value) {
        <%= op.field_name %>.SetValue(<%= op.type == 'std::string' || op.type == 'arg_list_t' ? 'std::move(value)' : 'value' %>);
    }

    bool WasSet<%= op.name.split(Regexp.union(['-','.'])).map(&:capitalize).join %>() const {
        return <%= op.field_name %>.WasSet();
    }

% end
// NOLINTNEXTLINE(readability-function-size)
    std::optional<Error> Validate() const {
% Common::options.each do |op|
%   next unless defined? op.possible_values
%   is_string = op.type == 'std::string' || op.type == 'arg_list_t'
%   possible_values = op.possible_values.map { |e| is_string ? Common::to_raw(e) : e }.join(', ')
        {
            std::unordered_set<<%= is_string ? "std::string" : op.type %>> possible_values{<%= possible_values %>};
%   if op.type != 'arg_list_t'
            std::vector<<%= op.type %>> values{<%= op.field_name %>.GetValue()};
%   else
            const auto &values = <%= op.field_name %>.GetValue();
%   end
            for (const auto &value : values) {
                if (possible_values.find(value) == possible_values.cend()) {
                    return Error("argument --<%= op.name %>: invalid value: '" + <%= is_string ? "value" : "std::to_string(value)" %> + \
                                 R"('. Possible values: <%= op.possible_values %>)");
                }
            }
        }
% end
        return {};
    }

private:
    static std::string GetExeDir(const std::string &exe_path) {
        auto pos = exe_path.find_last_of('/');
        return exe_path.substr(0, pos);
    }

% Common::options.each do |op|
%   next unless op.need_default_constant
    static constexpr <%= op.type %> <%= op.default_constant_name %> = <%= op.default %>;

% end
    std::string exe_dir_;
% Common::options.each do |op|
% if defined? op.delimiter
    PandArg<<%= op.type %>> <%= op.field_name %>{"<%= op.name %>", <%= op.default_value %>, <%= op.full_description %>, "<%= op.delimiter %>"};
% elsif defined? op.range
%   min, max = op.range.match('(\d+)\D*(\d+)').captures;
%   if op.default.to_i > max.to_i || op.default.to_i < min.to_i
%     abort "FAILED: Default value of argument " + op.name + " has out of range default parameter"
%   end
    PandArg<<%= op.type %>> <%= op.field_name %>{"<%= op.name %>", <%= op.default_value %>, <%= op.full_description %>, <%= min.to_i %>, <%= max.to_i %>};
% else
    PandArg<<%= op.type %>> <%= op.field_name %>{"<%= op.name %>", <%= op.default_value %>, <%= op.full_description %>};
% end
% end
};

}  // namespace <%= Common::module.namespace %>

#endif  // PANDA_<%= Common::module.name.upcase %>_OPTIONS_GEN_H_
